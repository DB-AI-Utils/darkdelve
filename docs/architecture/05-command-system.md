# 05 - Command System

## Purpose

Unified interface for all player actions. The command system validates commands against current game state, executes them through appropriate handlers, and returns results. This is the primary integration point between presentation layers and the game core.

---

## Responsibilities

1. Define all possible player commands
2. Validate commands against current game state and phase
3. Route commands to appropriate handlers
4. Return structured results with events and updated state
5. Provide available commands for current context

---

## Dependencies

- **01-foundation**: Types, Result
- **03-state-management**: GameState, StateStore, StateAction
- **04-event-system**: EventBus, GameEvent

---

## Interface Contracts

### Command Processor

```typescript
// ==================== Command Processor ====================

interface CommandProcessor {
  /**
   * Execute a command against current game state.
   * Returns result with events and optionally updated state.
   */
  execute(command: GameCommand): CommandResult;

  /**
   * Get all commands available in current state.
   * Used by presentation to show valid options.
   */
  getAvailableCommands(): AvailableCommand[];

  /**
   * Check if a specific command is valid without executing.
   */
  validate(command: GameCommand): ValidationResult;

  /**
   * Get current game phase.
   */
  getCurrentPhase(): GamePhase;

  /**
   * Get commands available for a specific phase (for help text).
   */
  getCommandsForPhase(phase: GamePhase): CommandDefinition[];
}

/**
 * Create command processor instance
 */
function createCommandProcessor(
  stateStore: StateStore,
  eventBus: EventBus,
  contentRegistry: ContentRegistry,
  rng: SeededRNG
): CommandProcessor;

// ==================== Command Result ====================

interface CommandResult {
  /** Whether command executed successfully */
  success: boolean;

  /** Error details if not successful */
  error?: CommandError;

  /** Events generated by this command */
  events: GameEvent[];

  /** New game state after command */
  state: GameState;

  /** Additional data for presentation */
  data?: CommandResultData;
}

interface CommandError {
  /** Machine-readable error code */
  code: CommandErrorCode;

  /** Human-readable message */
  message: string;

  /** Additional context */
  details?: Record<string, unknown>;
}

type CommandErrorCode =
  // Phase errors
  | 'INVALID_PHASE'
  | 'COMMAND_NOT_AVAILABLE'

  // Target errors
  | 'INVALID_TARGET'
  | 'TARGET_NOT_FOUND'

  // Resource errors
  | 'INSUFFICIENT_GOLD'
  | 'INSUFFICIENT_STAMINA'
  | 'INSUFFICIENT_SPACE'

  // State errors
  | 'ALREADY_EQUIPPED'
  | 'CANNOT_UNEQUIP'
  | 'ITEM_CURSED'
  | 'BLOCKED_BY_WATCHER'
  | 'COOLDOWN_ACTIVE'

  // Confirmation errors
  | 'CONFIRMATION_REQUIRED'

  // Stat check errors
  | 'STAT_CHECK_FAILED'

  // Limit errors
  | 'MAX_ITEMS_REACHED'
  | 'MAX_CONSUMABLES_REACHED';

type CommandResultData =
  | CombatResultData
  | LootResultData
  | EventResultData
  | MerchantResultData;

interface CombatResultData {
  type: 'combat';
  combatEnded: boolean;
  endResult?: 'victory' | 'defeat' | 'fled';
  damageDealt?: number;
  damageReceived?: number;
}

interface LootResultData {
  type: 'loot';
  itemsFound: ItemInfo[];
  goldFound: number;
}

interface EventResultData {
  type: 'event';
  outcome: string;
  success: boolean;
}

interface MerchantResultData {
  type: 'merchant';
  goldSpent?: number;
  goldReceived?: number;
}

// ==================== Available Commands ====================

interface AvailableCommand {
  /** The command definition */
  command: GameCommand;

  /** Display text for the command */
  displayText: string;

  /** Keyboard shortcut */
  shortcut: string;

  /** Whether command can be executed */
  enabled: boolean;

  /** Why disabled (if not enabled) */
  disabledReason?: string;

  /** Whether confirmation dialog needed */
  requiresConfirmation: boolean;

  /** Category for grouping in UI */
  category: CommandCategory;

  /** Resource cost preview */
  cost?: CommandCost;
}

type CommandCategory =
  | 'navigation'
  | 'combat'
  | 'item'
  | 'menu'
  | 'system';

interface CommandCost {
  type: 'stamina' | 'gold' | 'item' | 'dread';
  amount: number;
  itemId?: EntityId;
}

interface ValidationResult {
  valid: boolean;
  reason?: string;
  requiredPhase?: GamePhase;
  missingResources?: CommandCost[];
}

interface CommandDefinition {
  type: GameCommand['type'];
  displayName: string;
  description: string;
  shortcut: string;
  category: CommandCategory;
  phases: GamePhase[];
}
```

### Game Commands

```typescript
// ==================== Camp Commands ====================

interface ViewStashCommand {
  type: 'CAMP_VIEW_STASH';
}

interface ViewEquipmentCommand {
  type: 'CAMP_VIEW_EQUIPMENT';
}

interface ViewCharacterCommand {
  type: 'CAMP_VIEW_CHARACTER';
}

interface ViewChroniclerCommand {
  type: 'CAMP_VIEW_CHRONICLER';
}

interface ViewMerchantCommand {
  type: 'CAMP_VIEW_MERCHANT';
}

interface BeginExpeditionCommand {
  type: 'CAMP_BEGIN_EXPEDITION';
}

interface ReturnToMainMenuCommand {
  type: 'CAMP_RETURN_TO_MAIN';
}

// ==================== Stash Commands ====================

interface StashEquipItemCommand {
  type: 'STASH_EQUIP_ITEM';
  itemId: EntityId;
}

interface StashDropItemCommand {
  type: 'STASH_DROP_ITEM';
  itemId: EntityId;
  confirmed: boolean;
}

// ==================== Equipment Commands ====================

interface EquipItemCommand {
  type: 'EQUIP_ITEM';
  itemId: EntityId;
  slot: EquipmentSlot;
}

interface UnequipItemCommand {
  type: 'UNEQUIP_ITEM';
  slot: EquipmentSlot;
}

// ==================== Expedition Prep Commands ====================

interface PrepSelectBringItemCommand {
  type: 'PREP_SELECT_BRING_ITEM';
  itemId: EntityId;
}

interface PrepDeselectBringItemCommand {
  type: 'PREP_DESELECT_BRING_ITEM';
  itemId: EntityId;
}

interface PrepSelectConsumableCommand {
  type: 'PREP_SELECT_CONSUMABLE';
  templateId: string;
  fromStash: boolean;
}

interface PrepDeselectConsumableCommand {
  type: 'PREP_DESELECT_CONSUMABLE';
  slotIndex: number;
}

interface PrepConfirmExpeditionCommand {
  type: 'PREP_CONFIRM_EXPEDITION';
}

interface PrepCancelCommand {
  type: 'PREP_CANCEL';
}

// ==================== Merchant Commands ====================

interface MerchantBuyCommand {
  type: 'MERCHANT_BUY';
  templateId: string;
}

interface MerchantSellCommand {
  type: 'MERCHANT_SELL';
  itemId: EntityId;
}

interface MerchantBuybackCommand {
  type: 'MERCHANT_BUYBACK';
  itemId: EntityId;
}

interface MerchantIdentifyCommand {
  type: 'MERCHANT_IDENTIFY';
  itemId: EntityId;
}

// ==================== Navigation Commands ====================

interface MoveToRoomCommand {
  type: 'MOVE_TO_ROOM';
  roomId: string;
}

interface MoveBackCommand {
  type: 'MOVE_BACK';
}

// ==================== Combat Commands ====================

interface CombatLightAttackCommand {
  type: 'COMBAT_LIGHT_ATTACK';
}

interface CombatHeavyAttackCommand {
  type: 'COMBAT_HEAVY_ATTACK';
}

interface CombatDodgeCommand {
  type: 'COMBAT_DODGE';
}

interface CombatBlockCommand {
  type: 'COMBAT_BLOCK';
}

interface CombatPassCommand {
  type: 'COMBAT_PASS';
}

interface CombatUseItemCommand {
  type: 'COMBAT_USE_ITEM';
  itemId: EntityId;
}

interface CombatFleeCommand {
  type: 'COMBAT_FLEE';
}

// ==================== Treasure Commands ====================

interface TreasurePickLockCommand {
  type: 'TREASURE_PICK_LOCK';
}

interface TreasureForceOpenCommand {
  type: 'TREASURE_FORCE_OPEN';
}

interface TreasureSmashCommand {
  type: 'TREASURE_SMASH';
}

interface TreasureExamineCommand {
  type: 'TREASURE_EXAMINE';
}

interface TreasureLeaveCommand {
  type: 'TREASURE_LEAVE';
}

interface TreasurePickUpItemCommand {
  type: 'TREASURE_PICK_UP_ITEM';
  itemId: EntityId;
}

interface TreasurePickUpAllCommand {
  type: 'TREASURE_PICK_UP_ALL';
}

// ==================== Event Commands ====================

interface EventChooseCommand {
  type: 'EVENT_CHOOSE';
  choiceId: string;
}

// ==================== Rest Commands ====================

interface RestFullCommand {
  type: 'REST_FULL';
}

interface RestBriefCommand {
  type: 'REST_BRIEF';
}

interface RestMeditateCommand {
  type: 'REST_MEDITATE';
}

interface RestLeaveCommand {
  type: 'REST_LEAVE';
}

// ==================== Stairwell Commands ====================

interface StairwellDescendCommand {
  type: 'STAIRWELL_DESCEND';
}

interface StairwellExtractCommand {
  type: 'STAIRWELL_EXTRACT';
  paymentType?: 'gold' | 'item';
  itemId?: EntityId;
}

interface StairwellReturnCommand {
  type: 'STAIRWELL_RETURN';
}

// ==================== Threshold Commands ====================

interface ThresholdEnterBossCommand {
  type: 'THRESHOLD_ENTER_BOSS';
}

interface ThresholdReturnCommand {
  type: 'THRESHOLD_RETURN';
}

interface ThresholdRetreatCommand {
  type: 'THRESHOLD_RETREAT';
  paymentType: 'gold' | 'item';
  itemId?: EntityId;
}

// ==================== Item Management Commands ====================

interface UseConsumableCommand {
  type: 'USE_CONSUMABLE';
  slotIndex: number;
}

interface DropItemCommand {
  type: 'DROP_ITEM';
  itemId: EntityId;
  confirmed: boolean;
}

interface InspectItemCommand {
  type: 'INSPECT_ITEM';
  itemId: EntityId;
}

// ==================== System Commands ====================

interface SaveGameCommand {
  type: 'SAVE_GAME';
}

interface LoadGameCommand {
  type: 'LOAD_GAME';
  profileId: string;
}

interface CreateProfileCommand {
  type: 'CREATE_PROFILE';
  name: string;
  playerType: 'human' | 'ai_agent';
  classId: CharacterClass;
}

interface DeleteProfileCommand {
  type: 'DELETE_PROFILE';
  profileId: string;
  confirmed: boolean;
}

interface QuitCommand {
  type: 'QUIT';
  confirmed: boolean;
}

// ==================== Command Union ====================

type GameCommand =
  // Camp
  | ViewStashCommand
  | ViewEquipmentCommand
  | ViewCharacterCommand
  | ViewChroniclerCommand
  | ViewMerchantCommand
  | BeginExpeditionCommand
  | ReturnToMainMenuCommand

  // Stash
  | StashEquipItemCommand
  | StashDropItemCommand

  // Equipment
  | EquipItemCommand
  | UnequipItemCommand

  // Expedition Prep
  | PrepSelectBringItemCommand
  | PrepDeselectBringItemCommand
  | PrepSelectConsumableCommand
  | PrepDeselectConsumableCommand
  | PrepConfirmExpeditionCommand
  | PrepCancelCommand

  // Merchant
  | MerchantBuyCommand
  | MerchantSellCommand
  | MerchantBuybackCommand
  | MerchantIdentifyCommand

  // Navigation
  | MoveToRoomCommand
  | MoveBackCommand

  // Combat
  | CombatLightAttackCommand
  | CombatHeavyAttackCommand
  | CombatDodgeCommand
  | CombatBlockCommand
  | CombatPassCommand
  | CombatUseItemCommand
  | CombatFleeCommand

  // Treasure
  | TreasurePickLockCommand
  | TreasureForceOpenCommand
  | TreasureSmashCommand
  | TreasureExamineCommand
  | TreasureLeaveCommand
  | TreasurePickUpItemCommand
  | TreasurePickUpAllCommand

  // Event
  | EventChooseCommand

  // Rest
  | RestFullCommand
  | RestBriefCommand
  | RestMeditateCommand
  | RestLeaveCommand

  // Stairwell
  | StairwellDescendCommand
  | StairwellExtractCommand
  | StairwellReturnCommand

  // Threshold
  | ThresholdEnterBossCommand
  | ThresholdReturnCommand
  | ThresholdRetreatCommand

  // Item Management
  | UseConsumableCommand
  | DropItemCommand
  | InspectItemCommand

  // System
  | SaveGameCommand
  | LoadGameCommand
  | CreateProfileCommand
  | DeleteProfileCommand
  | QuitCommand;
```

### Phase Command Matrix

```typescript
// ==================== Phase Command Matrix ====================

/**
 * Defines which commands are valid in each phase.
 * Commands not listed for a phase are rejected.
 */
const PHASE_COMMANDS: Record<GamePhase, GameCommand['type'][]> = {
  // Camp phases
  camp_main: [
    'CAMP_VIEW_STASH',
    'CAMP_VIEW_EQUIPMENT',
    'CAMP_VIEW_CHARACTER',
    'CAMP_VIEW_CHRONICLER',
    'CAMP_VIEW_MERCHANT',
    'CAMP_BEGIN_EXPEDITION',
    'SAVE_GAME',
    'QUIT',
  ],

  camp_stash: [
    'STASH_EQUIP_ITEM',
    'STASH_DROP_ITEM',
    'CAMP_RETURN_TO_MAIN',
  ],

  camp_equipment: [
    'EQUIP_ITEM',
    'UNEQUIP_ITEM',
    'CAMP_RETURN_TO_MAIN',
  ],

  camp_merchant: [
    'MERCHANT_BUY',
    'MERCHANT_SELL',
    'MERCHANT_BUYBACK',
    'MERCHANT_IDENTIFY',
    'CAMP_RETURN_TO_MAIN',
  ],

  camp_chronicler: [
    'CAMP_RETURN_TO_MAIN',
  ],

  camp_character: [
    'CAMP_RETURN_TO_MAIN',
  ],

  // Expedition prep
  expedition_prep: [
    'PREP_SELECT_BRING_ITEM',
    'PREP_DESELECT_BRING_ITEM',
    'PREP_SELECT_CONSUMABLE',
    'PREP_DESELECT_CONSUMABLE',
    'PREP_CONFIRM_EXPEDITION',
    'PREP_CANCEL',
  ],

  expedition_confirm: [
    'PREP_CONFIRM_EXPEDITION',
    'PREP_CANCEL',
  ],

  // Dungeon phases
  dungeon_exploring: [
    'MOVE_TO_ROOM',
    'MOVE_BACK',
    'USE_CONSUMABLE',
    'EQUIP_ITEM',
    'UNEQUIP_ITEM',
    'DROP_ITEM',
    'INSPECT_ITEM',
  ],

  dungeon_combat: [
    'COMBAT_LIGHT_ATTACK',
    'COMBAT_HEAVY_ATTACK',
    'COMBAT_DODGE',
    'COMBAT_BLOCK',
    'COMBAT_PASS',
    'COMBAT_USE_ITEM',
    'COMBAT_FLEE',
  ],

  dungeon_treasure: [
    'TREASURE_PICK_LOCK',
    'TREASURE_FORCE_OPEN',
    'TREASURE_SMASH',
    'TREASURE_EXAMINE',
    'TREASURE_LEAVE',
    'TREASURE_PICK_UP_ITEM',
    'TREASURE_PICK_UP_ALL',
  ],

  dungeon_event: [
    'EVENT_CHOOSE',
  ],

  dungeon_rest: [
    'REST_FULL',
    'REST_BRIEF',
    'REST_MEDITATE',
    'REST_LEAVE',
  ],

  dungeon_stairwell: [
    'STAIRWELL_DESCEND',
    'STAIRWELL_EXTRACT',
    'STAIRWELL_RETURN',
    'USE_CONSUMABLE',
  ],

  dungeon_threshold: [
    'THRESHOLD_ENTER_BOSS',
    'THRESHOLD_RETURN',
    'THRESHOLD_RETREAT',
    'USE_CONSUMABLE',
  ],

  dungeon_boss: [
    'COMBAT_LIGHT_ATTACK',
    'COMBAT_HEAVY_ATTACK',
    'COMBAT_DODGE',
    'COMBAT_BLOCK',
    'COMBAT_PASS',
    'COMBAT_USE_ITEM',
    // Note: COMBAT_FLEE not available in boss
  ],

  // Terminal phases
  extracting: [],  // No commands, auto-advance
  dead: [],        // No commands, auto-advance to camp
  game_over: [
    'QUIT',
  ],
};
```

---

## Configuration Files

None. Command definitions are code, not config.

---

## Events Emitted/Subscribed

The command system emits events through the event bus based on command execution. Each command handler emits relevant events.

**Events commonly emitted:**
- Navigation: `ROOM_ENTERED`, `ROOM_CLEARED`, `FLOOR_DESCENDED`
- Combat: `COMBAT_STARTED`, `PLAYER_ATTACKED`, `ENEMY_ATTACKED`, etc.
- Items: `ITEM_EQUIPPED`, `ITEM_USED`, `ITEM_PURCHASED`, etc.
- Progression: `XP_GAINED`, `LEVEL_UP`, `GOLD_CHANGED`
- System: `GAME_SAVED`, `SESSION_STARTED`, `SESSION_ENDED`

---

## State Managed

The command processor doesn't manage its own state. It reads from and writes to the state store.

---

## Edge Cases and Error Handling

| Case | Handling |
|------|----------|
| Command in wrong phase | Return error: INVALID_PHASE |
| Target doesn't exist | Return error: TARGET_NOT_FOUND |
| Not enough gold | Return error: INSUFFICIENT_GOLD |
| Not enough stamina | Return error: INSUFFICIENT_STAMINA |
| Inventory full | Return error: INSUFFICIENT_SPACE |
| Item is cursed | Return error: ITEM_CURSED |
| Watcher blocking | Return error: BLOCKED_BY_WATCHER |
| Need confirmation | Return error: CONFIRMATION_REQUIRED |
| Stat check failed | Return error: STAT_CHECK_FAILED |
| Cooldown active | Return error: COOLDOWN_ACTIVE |
| Unknown command type | Log error, return generic error |

---

## Test Strategy

### Unit Tests

1. **Validation Tests** (per phase)
   - Test each command is valid in expected phases
   - Test each command is rejected in wrong phases
   - Test resource validation (gold, stamina)
   - Test target validation (item exists, room accessible)

2. **Execution Tests** (per command)
   - Test successful execution updates state
   - Test correct events are emitted
   - Test error cases return proper errors

3. **Available Commands Tests**
   - Test correct commands returned per phase
   - Test disabled states with reasons
   - Test cost calculations

### Integration Tests

1. Full command sequences (camp → prep → dungeon → combat → extract)
2. Error recovery (invalid command doesn't corrupt state)
3. Event emission matches documentation

### Property Tests

```typescript
property("command execution is deterministic", (commands, seed) => {
  const rng1 = createRNG(seed);
  const rng2 = createRNG(seed);
  const processor1 = createCommandProcessor(/*...*/, rng1);
  const processor2 = createCommandProcessor(/*...*/, rng2);

  for (const cmd of commands) {
    const result1 = processor1.execute(cmd);
    const result2 = processor2.execute(cmd);
    if (result1.success !== result2.success) return false;
  }
  return true;
});
```

---

## Implementation Notes

### Command Handler Pattern

Each command type has a dedicated handler:

```typescript
type CommandHandler<T extends GameCommand> = (
  state: GameState,
  command: T,
  context: HandlerContext
) => CommandResult;

interface HandlerContext {
  eventBus: EventBus;
  contentRegistry: ContentRegistry;
  rng: SeededRNG;
  dispatch: (action: StateAction) => void;
}
```

### Handler Registration

```typescript
const handlers: Record<GameCommand['type'], CommandHandler<any>> = {
  'COMBAT_LIGHT_ATTACK': handleLightAttack,
  'COMBAT_HEAVY_ATTACK': handleHeavyAttack,
  // ... all handlers
};
```

### Validation Before Execution

Always validate before executing:

```typescript
function execute(command: GameCommand): CommandResult {
  const validation = this.validate(command);
  if (!validation.valid) {
    return {
      success: false,
      error: { code: 'COMMAND_NOT_AVAILABLE', message: validation.reason },
      events: [],
      state: this.stateStore.getState(),
    };
  }
  return handlers[command.type](this.stateStore.getState(), command, this.context);
}
```

---

## Public Exports

```typescript
// src/core/commands/index.ts

export type {
  CommandProcessor,
  CommandResult,
  CommandError,
  CommandErrorCode,
  CommandResultData,
  CombatResultData,
  LootResultData,
  EventResultData,
  MerchantResultData,
  AvailableCommand,
  CommandCategory,
  CommandCost,
  ValidationResult,
  CommandDefinition,

  // All command types
  GameCommand,
  ViewStashCommand,
  ViewEquipmentCommand,
  // ... (all command interfaces)
};

export {
  createCommandProcessor,
  PHASE_COMMANDS,
};
```
